#!/usr/bin/env python

###############################################################################
##
##  Copyright 2014 Jeet Sukumaran.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
##
## Modified by Jeet Sukumaran from "quickfind"::
##
##      quickfind
##      https://github.com/Refefer/quickfind
##      By Andrew Stanton.
##
################################################################################

"""
Find, list and select a file for editing, dynamically filtering listings
using fuzzy-matching or regular expression-matching as you type.
"""

import os
import sys
import termios
import heapq
import argparse
import curses
import fcntl
import struct
import fnmatch
import re
import itertools
import collections
try:
    from StringIO import StringIO # Python 2 legacy support: StringIO in this module is the one needed (not io)
except ImportError:
    from io import StringIO # Python 3
try:
    import fsnix.util as util
    walk = util.walk
except ImportError:
    walk = os.walk
if sys.version_info.major >= 3:
    unicode_str = lambda x: str(x)
else:
    unicode_str = lambda x: unicode(x, errors="ignore")

__prog__ = os.path.basename(__file__)
__version__ = "1.0.0"
__description__ = __doc__
__author__ = 'Jeet Sukumaran'
__copyright__ = 'Copyright (C) 2014 Jeet Sukumaran.'

def dump_stack(out=None):
    import inspect
    if out is None:
        out = sys.stderr
    for frame, filename, line_num, func, source_code, source_index in inspect.stack()[2:]:
        if source_code is None:
            out.write("{}: {}\n".format(filename, line_num))
        else:
            out.write("{}: {}: {}\n".format(filename, line_num, source_code[source_index].strip()))

def truncate_front(line, length=70):
    reduce_amt = len(line) - length
    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line

    reduce_amt += 3 # for the ellipsis
    return '...'+line[reduce_amt:]

def truncate_middle(line, length=70):
    reduce_amt = len(line) - length

    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line

    reduce_amt += 3 # for the ellipsis

    start = (len(line) / 2) - (reduce_amt / 2)
    end = start + reduce_amt
    return "%s...%s" % (line[:start], line[end:])

class Entry(object):

    def __init__(self,
            dirname,
            filename,
            score,
            match_start,
            match_end,
            match_basename_only):
        self.dirname = dirname
        self.filename = filename
        self.score = score
        self.match_basename_only = match_basename_only
        self._match_start_offset = match_start
        self._match_end_offset = match_end

    def _get_filepath(self):
        return os.path.join(self.dirname, self.filename)
    filepath = property(_get_filepath)

    def _start_of_basename_in_filepath(self):
        return len(os.path.join(self.dirname, ""))
    start_of_basename_in_filepath = property(_start_of_basename_in_filepath)

    def _get_match_start(self):
        if self.match_basename_only:
            return self.start_of_basename_in_filepath + self._match_start_offset
        else:
            return self._match_start_offset
    def _set_match_start(self, v):
        self._match_start_offset = v
    match_start = property(_get_match_start, _set_match_start)

    def _get_match_end(self):
        if self.match_basename_only:
            return self.start_of_basename_in_filepath + self._match_end_offset
        else:
            return self._match_end_offset
    def _set_match_end(self, v):
        self._match_end_offset = v
    match_end = property(_get_match_end, _set_match_end)

    def __lt__(self, other):
        return self.score < other.score

class CursesPrinter(object):

    class OutOfWindowBoundsException(Exception):
        pass

    def __init__(self):
        self.querylen = 0

    def init(self):

        # setup window
        self.window = curses.initscr()
        curses.start_color()
        curses.use_default_colors()
        curses.noecho()

        # color for default text
        curses.init_pair(1, -1, -1)
        self.default_color = curses.color_pair(1)

        # color for matched text
        # curses.init_pair(2, -1, -1)
        ## TODO: allow configuration from environmental variable or rc file!
        curses.init_pair(2, curses.COLOR_GREEN, -1)
        self.match_color = curses.color_pair(2) | curses.A_UNDERLINE

    def cleanup(self):
        curses.echo()
        curses.endwin()

    def print_query(self, query):
        q = "$ " + query
        self.querylen = len(q)
        height, width = self.window_size()
        self.window.addstr(height-1, 0, q)

    def print_item(self, idx, item, is_selected, query):
        height, width = self.window_size()
        row = height - idx  - 2
        if row < 0:
            raise CursesPrinter.OutOfWindowBoundsException
        self.window.move(row, 0)
        entry = truncate_middle(item.filepath, width)
        if is_selected:
            leader = "> "
            weight = curses.A_REVERSE
        else:
            leader = "  "
            weight = curses.A_NORMAL
        if item.score > 0:
            left = entry[:item.match_start]
            main = entry[item.match_start:item.match_end]
            right = entry[item.match_end:]
            self.window.addstr(leader)
            self.window.addstr(left, self.default_color | weight)
            self.window.addstr(main, self.match_color | weight)
            self.window.addstr(right, self.default_color | weight)
        else:
            self.window.addstr(leader + entry, self.default_color | weight)

    def clear(self):
        self.window.clear()

    def flush(self):
        height, width = self.window_size()
        self.window.move(height-1, self.querylen)
        self.window.refresh()

    def move(self, y, x):
        self.window.move(y, x)
        self.window.refresh()

    def window_size(self):
        # return self.window.getmaxyx() # not as responsive to resizing?
        return getDims()

class Searcher(object):

    def __init__(self,
            ranker,
            output,
            whitespace_separated_multiquery=False,
            match_basename_only=False,
            match_type="fuzzy"):
        self.ranker = ranker
        self.output = output
        self.whitespace_separated_multiquery = whitespace_separated_multiquery
        self.match_basename_only = match_basename_only
        self.match_type = match_type

    def _getch(self, blocking=True):
        if blocking:
            # self.output.window.timeout(-1)
            self.output.window.nodelay(0)
        else:
            # self.output.window.timeout(100)
            self.output.window.nodelay(1)
        ch = self.output.window.getch()
        ### FOLLOWING HACK NOT NEEDED ANY MORE, DUE TO FOLLOWING APPROACH::
        ###
        ###    with os.fdopen(0, 'r') as src:
        ###       for item in src.read().split("\n"):
        ###            # do stuff!
        ###    sys.stdin = open("/dev/tty", "r")
        ###
        # if blocking and ch == -1:
        #     # We are here because files were read from standard input
        #     # and now input is unavailable. This hack works on POSIX
        #     # systems ... but ARROW keys lead to exit in the loop
        #     # because we checking for escape (by itself) in a non-blocking
        #     # way.
        #     import tty
        #     fd = sys.stdin.fileno()
        #     tty_mode = tty.tcgetattr(fd)
        #     tty.setcbreak(fd)
        #     try:
        #         ch = ord(os.read(fd, 1))
        #     finally:
        #         tty.tcsetattr(fd, tty.TCSAFLUSH, tty_mode)
        #     assert isinstance(ch, int)
        if blocking: # restore
            # self.output.window.timeout(-1)
            self.output.window.nodelay(0)
        return ch

    def _new_heap(self, query, cur_heap):
        newHeap = []
        ranker = self.ranker(query=query,
                whitespace_separated_multiquery=self.whitespace_separated_multiquery,
                match_basename_only=self.match_basename_only,
                match_type=self.match_type)
        for w, item in cur_heap:
            item.match_basename_only = self.match_basename_only # needs to be updated here
            try:
                score, match_start, match_end = ranker.rank(item)
            except FuzzyRanker.IncompleteRegularExpressionPatternException:
                return cur_heap
            if score:
                item.score = score
                item.match_start = match_start
                item.match_end = match_end
                heapq.heappush(newHeap, (score, item))
            else:
                item.score = 0
                item.match_start = 0
                item.match_end = 0
        return newHeap

    def _reset_search(self, current_query, current_heaps):
        current_heaps = current_heaps[:1]
        old_query = current_query
        current_query = ""
        for ch in old_query:
            current_query += ch
            current_heaps.append(self._new_heap(current_query, current_heaps[-1]))
        return current_heaps

    def _select_next(self, current_selected):
        # Since we display from the bottom up, moving 'down' or 'next' means
        # moving to a *higher*-scoring result, which requires *decrement* the
        # index to move *up* the list, which is sorted incrementally by score.
        return max(0, current_selected - 1)

    def _select_previous(self, current_selected, max_results):
        # Since we display from the bottom up, moving 'up' or 'previous' means
        # moving to a *lower*-scoring result, which requires *incrementing* the
        # index to move *down* the list, which is sorted incrementally by score.
        return min(min(self.output.window_size()[0]-2, max_results), current_selected + 1)

    def _loop(self, current_heaps):
        heapq.heapify(current_heaps[0])
        current_query = ""
        selected = 0
        while True:
            self.output.window.timeout(-1)
            next_char = self._getch(blocking=True)

            # Escape: could be just Escape, could be Ansi escape for
            # arrows
            if next_char == 27:
                # just escape? try non-blocking read to see if
                # any other characters
                next_char = self._getch(blocking=False)
                if next_char == -1:
                    raise KeyboardInterrupt()
                # other characters available
                # assuming arrow-key, we discard
                # the current and read the next
                next_char = self._getch(blocking=True)
                # Up/down
                if next_char == 65:
                    # <UP>
                    selected = self._select_previous(selected, len(current_heaps[-1]))
                elif next_char == 66:
                    # <DOWN>
                    selected = self._select_next(selected)
            elif next_char == 14:
                # <CTRL-N>: Next
                selected = self._select_next(selected)
            elif next_char == 16:
                # <CTRL-P>: Previous
                selected = self._select_previous(selected, len(current_heaps[-1]))
            elif next_char == 2:
                # <CTRL-B>: Cycle full-path vs. basename matching
                self.match_basename_only = not self.match_basename_only
                current_heaps = self._reset_search(current_query, current_heaps)
            elif next_char == 6:
                # <CTRL-F>: Fuzzy-matching mode
                self.match_type = "fuzzy"
                current_heaps = self._reset_search(current_query, current_heaps)
            elif next_char == 5:
                # <CTRL-E>: Regular-expression matching mode
                self.match_type = "regexp"
                current_heaps = self._reset_search(current_query, current_heaps)
            elif next_char == 12:
                # <CTRL-L>: Literal or raw matching mode
                self.match_type = "literal"
                current_heaps = self._reset_search(current_query, current_heaps)
            elif next_char == 23:
                # <CTRL-W>: Toggle whitespace-separated multi-search
                self.whitespace_separated_multiquery = not self.whitespace_separated_multiquery
                current_heaps = self._reset_search(current_query, current_heaps)
            else:
                # Selected
                if next_char == 10 or next_char == 13: # enter
                    h = current_heaps[-1]
                    for _ in range(selected):
                        if not h: break
                        heapq.heappop(h)
                    return heapq.heappop(h)[1] if h else None
                selected = 0
                if next_char in (3, 4, 26, 28):
                    # <CTRL-C>, <CTRL-D>, <CTRL-Z>, etc.
                    raise KeyboardInterrupt()
                elif next_char in (8, 127):
                    # Delete/backspace
                    if current_query != "":
                        current_query = current_query[:-1]
                        current_heaps.pop()
                else:
                    try:
                        current_query += chr(next_char)
                        current_heaps.append(self._new_heap(current_query, current_heaps[-1]))
                    except ValueError:
                        pass
            self._echo(current_query, current_heaps[-1], selected)

    def _echo(self, current_query, heap, selected):
        self.output.clear()
        self.output.print_query(current_query)
        for i, (score, item) in enumerate(heap):
            try:
                self.output.print_item(i, item, i==selected, current_query)
            except CursesPrinter.OutOfWindowBoundsException:
                break
        self.output.flush()

    def run(self, items):
        self.output.init()
        try:
            heap = [(i.score, i) for i in items]
            heap.sort()
            self._echo("", heap, 0)
            return self._loop([heap])
        finally:
            self.output.cleanup()

class DirectorySource(object):

    dot_dirs_ignore_pattern = None

    def __init__(self,
            include_filename_patterns=None,
            ignore_directories=True,
            ignore_files=True,
            ignore_gitignores=True,
            dirs_to_exclude=None,
            files_to_exclude=None,
            paths_to_exclude=None):
        self.ignore_directories = ignore_directories
        self.ignore_files = ignore_files
        self.ignore_gitignores = ignore_gitignores
        if include_filename_patterns is None:
            self.include_filename_pattern = None
        else:
            self.include_filename_pattern = re.compile("(" + "|".join(include_filename_patterns) + ")")
        if dirs_to_exclude is None:
            self.dirs_to_exclude = None
        else:
            self.dirs_to_exclude = re.compile("(" + "|".join(dirs_to_exclude) + ")")
        if files_to_exclude is None:
            self.files_to_exclude = None
        else:
            self.files_to_exclude = re.compile("(" + "|".join(files_to_exclude) + ")")
        if paths_to_exclude is None:
            self.paths_to_exclude = None
        else:
            self.paths_to_exclude = re.compile("(" + "|".join(paths_to_exclude) + ")")
        if DirectorySource.dot_dirs_ignore_pattern is None:
            dot_dirs_to_ignore = ["git", "svn", "hg"]
            dot_dirs_to_ignore = ["(.*/|)\.{}".format(d) for d in dot_dirs_to_ignore]
            dot_dirs_ignore_pattern = "(" + "|".join(dot_dirs_to_ignore) + ")"
            DirectorySource.dot_dirs_ignore_pattern = re.compile(dot_dirs_ignore_pattern)

    def recurse_directory_up(self, dirname):
        if os.path.isdir(dirname):
            while True:
                yield dirname
                newdir = os.path.dirname(dirname)
                if not newdir or newdir == dirname:
                    break
                dirname = newdir

    def find_parent_gis(self, start_dir):
        gitignore_filters = []
        dirs = self.recurse_directory_up(start_dir)
        for dirname in dirs:
            if dirname == start_dir:
                continue
            pgi = os.path.join(dirname, '.gitignore')
            if os.path.isfile(pgi):
                gitignore_filters.append(GitIgnoreFilter(dirname, '.gitignore'))
        gitignore_filters.reverse()
        return gitignore_filters

    def fetch(self, start_dir=".", results=None):
        gitignore_filters = []
        all_filters = []
        if self.ignore_gitignores:
            self.find_parent_gis(start_dir)
        if results is None:
            results = []
        for dirname, dirs, filenames in walk(start_dir):
            if DirectorySource.dot_dirs_ignore_pattern.match(dirname):
                continue
            if self.dirs_to_exclude is not None and self.dirs_to_exclude.match(dirname):
                continue
            names = []
            if not self.ignore_files:
                for f in filenames:
                    if ( (self.files_to_exclude is None or not self.files_to_exclude.match(f))
                            and (self.include_filename_pattern is None or self.include_filename_pattern.match(f))):
                        # if self.paths_to_exclude is not None:
                        #     # only do this if actual paths to exclude
                        #     ff = os.path.join(dirname, f)
                        #     if not self.paths_to_exclude.match(f):
                        #         names.append(f)
                        # else:
                        #     names.append(f)
                        names.append(f)
            if not self.ignore_directories:
                names.extend(dirs)
            if self.ignore_gitignores and '.gitignore' in filenames:
                gif = GitIgnoreFilter(dirname, '.gitignore')
                gitignore_filters.append((dirname, gif))
            all_filters.extend(gitignore_filters)
            while all_filters:
                path, filter_obj = all_filters[-1]
                if dirname.startswith(path):
                    break
                all_filters.pop()
            fltr = None
            if all_filters:
                fltr = all_filters[-1][1]
            for name in names:
                if fltr is None or fltr(name, dirname):
                    entry = Entry(dirname=dirname,
                            filename=name,
                            score=len(results),
                            match_start=0,
                            match_end=0,
                            match_basename_only=False)
                    results.append(entry)
            # have to delete the names manually
            if fltr is not None:
                for i in range(len(dirs) - 1, -1, -1):
                    if not fltr(dirs[i], dirname):
                        del dirs[i]
        return results

class GitIgnoreFilter(object):
    # Optimization
    lastdir = None
    last_path_filter = None

    globchars = re.compile('[*\[\]?]')
    def __init__(self, dirname, filename):
        self.dirname = dirname
        self.fn = os.path.join(dirname, filename)
        path_filters = []
        glob_filters = []
        exact_filters = set(['.git'])
        with open(self.fn) as f:
            gc = self.globchars
            for fn in f:
                if fn.startswith('#'):
                    continue
                fn = fn.strip()
                if fn.startswith('/') or fn.endswith('/'):
                    path_filters.append(fn)
                elif gc.search(fn) is not None:
                    glob_filters.append(fn)
                else:
                    exact_filters.add(fn)
        if glob_filters:
            self.glob_filters = glob_filters
        else:
            self.glob_filters = []
        self.exact_filters = exact_filters
        self.path_filters = self.setup_path_filters(path_filters)

    def setup_path_filters(self, path_filters):
        dirmaps = {}
        for pf in path_filters:
            while pf.endswith('/'):
                pf = pf[:-1]
            dirname, basename = os.path.split(pf)
            dm = os.path.join(self.dirname, dirname).rstrip('/')
            glob = basename.strip()
            if dm in dirmaps:
                dirmaps[dm].append(glob)
            else:
                dirmaps[dm] = [glob]
        return dirmaps

    def __call__(self, fn, dirname):
        # check exact
        if fn in self.exact_filters:
            return False
        # Check global globs
        for f in self.glob_filters:
            if fnmatch.fnmatch(os.path.join(dirname, fn), f):
                return False
            if fnmatch.fnmatch(fn, f):
                return False
        lpf = self.path_filters.get(dirname)
        # check path dependent globs
        if lpf is not None:
            for f in lpf:
                if fnmatch.fnmatch(fn, f):
                    return False
        return True

class FuzzyRanker(object):

    class IncompleteRegularExpressionPatternException(Exception):
        pass

    def match_and_score(query, s, match_type):
        if match_type == "fuzzy":
            pattern = '.*?'.join(map(re.escape, list(query)))
        elif match_type == "literal":
            pattern = ''.join(map(re.escape, list(query)))
        elif match_type == "regexp":
            pattern = query
        else:
            raise TypeError("Unrecognized pattern type: '{}'".format(match_type))
        try:
            match = re.search(pattern, s, re.I)
        except re.error:
            if match_type == "regexp":
                raise FuzzyRanker.IncompleteRegularExpressionPatternException()
        if match is None:
            result = 0
        else:
            # return 100 / ((1+match.start()) * (match.end()-match.start()+1))
            result = 1000.0 / ((1 + match.start()) * (match.end() - match.start() + 1))
        return match, result
    match_and_score = staticmethod(match_and_score)

    def __init__(self,
            query,
            whitespace_separated_multiquery=False,
            match_basename_only=False,
            match_type="fuzzy"):
        self.whitespace_separated_multiquery = whitespace_separated_multiquery
        self.match_basename_only =match_basename_only
        self.weight_f = lambda f: f.dirname.count(os.sep) ** 0.5
        self.qs = query.lower()
        if self.whitespace_separated_multiquery:
            self.qs = self.qs.split()
        else:
            self.qs = [self.qs]
        self.match_type = match_type

    def rank(self, item):
        if self.match_basename_only:
            part = item.filename
        else:
            part = item.filepath
        agg_score = 0.0
        match_start = len(part)
        match_end = -1
        for q in self.qs:
            match, score = self.match_and_score(q, part, self.match_type)
            if score is None or score == 0:
                # return None, None, None
                return None, None, None
            if score is not None:
                match_start = min(match_start, match.start())
                match_end = max(match_end, match.end())
                agg_score += score
        # return agg_score + self.weight_f(item), match_start, match_end
        return agg_score, match_start, match_end

def getDims():
    env = os.environ
    def ioctl_GWINSZ(fd):
        try:
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
        except:
            return
        return cr

    return ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2) or (25, 80)

##############################################################################
## Main Code

class Runner(object):
    def __init__(self, args):
        self.args = args
        self.editor_path = os.environ.get("FUZZYSNAKE_EDITOR", os.environ.get("EDITOR", "vi"))

    def find(self):
        raise NotImplementedError()

    def run(self):
        filename = self.find()
        if filename is not None:
            if args.action_type == "edit":
                try:
                    os.execvp(self.editor_path, [self.editor_path, filename])
                except:
                    sys.stderr.write("Failed to execute: os.execvp('{}', ['{}', {}])\n".format(self.editor_path, self.editor_path, filename))
                    sys.exit(1)
            elif args.action_type == "print":
                sys.stdout.write(filename)
                sys.stdout.write("\n")
                sys.exit(0)
            elif args.action_type == "open":
                try:
                    os.execvp('open', ['open', filename])
                except:
                    sys.stderr.write("Failed to execute: os.execvp('open', ['open', {}])\n".format(filename))
                    sys.exit(1)
            else:
                sys.exit("Unrecognized action: '{}'".format(args.action_type))

class DirRun(Runner):

    def find(self):
        ignore_gitignores = self.args.include_gitignore_files
        if self.args.directory_search_mode:
            ignore_directories = False
            ignore_files = True
        else:
            ignore_directories = True
            ignore_files = False
        ds = DirectorySource(
                include_filename_patterns=args.include_filename_pattern,
                ignore_directories=ignore_directories,
                ignore_files=ignore_files,
                ignore_gitignores=ignore_gitignores,
                dirs_to_exclude=args.dirs_to_exclude,
                files_to_exclude=args.files_to_exclude)
        search_paths = self.args.paths
        if not search_paths:
            search_paths = ["."]
        items = []
        for path in search_paths:
            if path == "-":
                if sys.platform.startswith('win'):
                    raise NotImplementedError("Reading from standard input is not supported on this system at this time")
                # NOTE: To allow us to continue to get input from the tty
                # standard input in the curses window in the interactive loop,
                # We do *not* read from `sys.stdin` directly here. Instead we open
                # a new file object bound to the system file descriptor '0'
                # (standard input), and read from that. After this is done and
                # closed (using the context manager), we must set sys.stdin's
                # file descriptor to the tty opened for reading.
                with os.fdopen(0, 'r') as src:
                    for item in src.read().split("\n"):
                        item = unicode_str(item)
                        item = os.path.expandvars(os.path.expanduser(item))
                        dirname = os.path.dirname(item)
                        basename = os.path.basename(item)
                        entry = Entry(dirname=dirname,
                                filename=basename,
                                score=len(items),
                                match_start=0,
                                match_end=0,
                                match_basename_only=False)
                        items.append(entry)
                sys.stdin = open("/dev/tty", "r")
            else:
                ds.fetch(path, items)
        if not items:
            sys.stderr.write("No valid files or directories found.\n")
            sys.exit(0)
        ranker = FuzzyRanker
        s = Searcher(ranker=ranker,
                output=CursesPrinter(),
                whitespace_separated_multiquery=self.args.multi_pattern,
                match_basename_only=self.args.basename_only_match,
                match_type=self.args.match_type,
                )
        try:
            found = s.run(items)
        except KeyboardInterrupt:
            sys.exit(0)

        if found is not None:
            found = os.path.join(found.dirname, found.filename)
        return found

def build_arg_parser():
    parser = argparse.ArgumentParser(description=__description__)
    parser.add_argument("--version", action="version", version="FuzzySnake " + __version__)

    source_options_group = parser.add_argument_group("Source Options")
    source_options_group.add_argument(
            "paths",
            metavar="DIR",
            nargs="*",
            help="Top-level directory path(s) to search. Defaults to "
            "current directory ('{}').".format(os.curdir))

    query_options_section = parser.add_argument_group("Query Options")
    query_options_section.add_argument(
            "-m", "--multi-pattern",
            action="store_true",
            help="Whitespace-separated multiple-queries: whitespaces in "
            "the query will be treated as separators for query terms, "
            "allowing multiple query terms to be used simultaneosly. "
            "If not specified, defaults to entire expression being "
            "treated as single pattern. Use `<CTRL-W>` to toggle this "
            "option on and off during the search.")
    query_options_section.add_argument(
            "-d", "--directory-paths",
            action="store_true",
            dest="directory_search_mode",
            default=False,
            help="Search for directory paths instead of filenames.")
    query_options_section.add_argument(
            "-b", "--basename-only-match",
            action="store_true",
	    help="Restrict match to the basename or tail of the path only "
	    "(by default, entire path will be matched). Use `<CTRL-B>` to "
	    "toggle this option on and off during the search.")

    match_type_section = parser.add_argument_group("Match Mode Options")
    match_type_group = match_type_section.add_mutually_exclusive_group()
    match_type_group.add_argument(
            "-f", "--fuzzy",
            action="store_const",
            dest="match_type",
            const="fuzzy",
	    help="[DEFAULT] Fuzzy-matching mode: pattern is matched on a "
	    "character-by-character basis, with characters required to "
	    "occur in the same order as the pattern, but not necessarily "
	    "consecutively (an arbitrary number of extra characters are "
	    "allowed between matched characters). You can force selection "
	    "of this mode during the search by typing `<CTRL-R>`.")
    match_type_group.add_argument(
            "-e", "--regexp",
            action="store_const",
            dest="match_type",
            const="regexp",
	    help="Regular-expression mode: patterns are matched as full "
	    "(Python) regular expression patterns. You can force selection "
	    "of this mode during the search by typing `<CTRL-E>`.")
    match_type_group.add_argument(
            "-l", "--literal",
            action="store_const",
            dest="match_type",
            const="literal",
	    help="Literal-matching mode: patterns are matched exactly as "
	    "given. You can force selection of this mode during the search "
	    "by typing `<CTRL-L>`.")
    parser.set_defaults(match_type="fuzzy")

    target_type_options = parser.add_argument_group("File Type Options",
	    "Constrain the search to specific types of files. If one or "
	    "more of the following are specified, then files of other "
	    "types will be excluded."
            )
    target_type_options.add_argument(
            "--actionscript",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.as$|.*\.mxml$",
            help="ActionScript")
    target_type_options.add_argument(
            "--ada",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.ada$|.*\.adb$|.*\.ads$",
            help="Ada")
    target_type_options.add_argument(
            "--asm",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.asm$|.*\.s$",
            help="ASM")
    target_type_options.add_argument(
            "--asp",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.asp$",
            help="ASP")
    target_type_options.add_argument(
            "--aspx",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.master$|.*\.ascx$|.*\.asmx$|.*\.aspx$|.*\.svc$",
            help="ASPX")
    target_type_options.add_argument(
            "--autotools",
            action="append_const",
            dest="include_filename_pattern",
            const=r"Makefile.am|configure.ac",
            help="Autotools")
    target_type_options.add_argument(
            "--batch",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.bat$|.*\.cmd$",
            help="MS-DOS/Windows batch")
    target_type_options.add_argument(
            "--cfmx",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.cfc$|.*\.cfm$|.*\.cfml$",
            help="ColdFusion")
    target_type_options.add_argument(
            "--clojure",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.clj$",
            help="Clojure")
    target_type_options.add_argument(
            "--cmake",
            action="append_const",
            dest="include_filename_pattern",
            const=r"CMakeLists\.txt|.*\.cmake$",
            help="CMake")
    target_type_options.add_argument(
            "--coffeescript",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.coffee$",
            help="CoffeeScript")
    target_type_options.add_argument(
            "--cpp",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.cpp$|.*\.cc$|.*\.cxx$|.*\.c\+\+$|.*\.c$|.*\.m$|.*\.hpp$|.*\.hh$|.*\.h$|.*\.hxx|.*\.h\+\+$|.*\.inc$",
            help="C++ and C)")
    target_type_options.add_argument(
            "--csharp",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.cs$",
            help="C#")
    target_type_options.add_argument(
            "--css",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.css$",
            help="CSS")
    target_type_options.add_argument(
            "--dart",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.dart$",
            help="Dart")
    target_type_options.add_argument(
            "--delphi",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.pas$|.*\.int$|.*\.dfm$|.*\.nfm$|.*\.dof$|.*\.dpk$|.*\.dproj$|.*\.groupproj$|.*\.bdsgroup$|.*\.bdsproj$",
            help="Delphi")
    target_type_options.add_argument(
            "--elisp",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.el$",
            help="Emacs Lisp")
    target_type_options.add_argument(
            "--elixir",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.ex$|.*\.exs$",
            help="Elixir")
    target_type_options.add_argument(
            "--erlang",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.erl$|.*\.hrl$",
            help="Erlang")
    target_type_options.add_argument(
            "--fortran",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.f$|.*\.f77$|.*\.f90$|.*\.f95$|.*\.f03$|.*\.for$|.*\.ftn$|.*\.fpp$",
            help="Fortran")
    target_type_options.add_argument(
            "--go",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.go$",
            help="Go")
    target_type_options.add_argument(
            "--groovy",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.groovy$|.*\.gtmpl$|.*\.gpp$|.*\.grunit$|.*\.gradle$",
            help="Groovy")
    target_type_options.add_argument(
            "--haskell",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.hs$|.*\.lhs$",
            help="Haskell")
    target_type_options.add_argument(
            "--html",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.htm$|.*\.html$",
            help="HTML")
    target_type_options.add_argument(
            "--java",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.java$|.*\.properties$",
            help="Java")
    target_type_options.add_argument(
            "--js",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.js$",
            help="JavaScript")
    target_type_options.add_argument(
            "--json",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.json$",
            help="JSON")
    target_type_options.add_argument(
            "--jsp",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.jsp$|.*\.jspx$|.*\.jhtm$|.*\.jhtml$",
            help="JavaServerPages")
    target_type_options.add_argument(
            "--less",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.less$",
            help="Less")
    target_type_options.add_argument(
            "--lisp",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.lisp$|.*\.lsp$",
            help="Lisp")
    target_type_options.add_argument(
            "--lua",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.lua$",
            help="Lua")
    target_type_options.add_argument(
            "--make",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.mk$|.*\.mak$|makefile|Makefile|GNUmakefile",
            help="Make")
    target_type_options.add_argument(
            "--markdown",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.mdown|.*\.markdown|.*\.md$",
            help="Markdown")
    target_type_options.add_argument(
            "--matlab",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.m$",
            help="MATLAB")
    target_type_options.add_argument(
            "--objc",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.m$|.*\.h$",
            help="Objective-C")
    target_type_options.add_argument(
            "--objcpp",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.mm$|.*\.h$",
            help="Objective-C++")
    target_type_options.add_argument(
            "--ocaml",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.ml$|.*\.mli$",
            help="OCaml")
    target_type_options.add_argument(
            "--parrot",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.pir$|.*\.pasm$|.*\.pmc$|.*\.ops$|.*\.pod$|.*\.pg$|.*\.tg$",
            help="Parrot")
    target_type_options.add_argument(
            "--perl",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.pl$|.*\.pm$|.*\.pod$|.*\.t$|.*\.psgi$",
            help="Perl")
    target_type_options.add_argument(
            "--perl-test",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.t$",
            help="Perl test")
    target_type_options.add_argument(
            "--php",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.php$|.*\.phpt$|.*\.php3$|.*\.php4$|.*\.php5$|.*\.phtml$",
            help="PHP")
    target_type_options.add_argument(
            "--plone",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.pt$|.*\.cpt$|.*\.metadata$|.*\.cpy$|.*\.py$",
            help="Plone")
    target_type_options.add_argument(
            "--python",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.py$",
            help="Python")
    target_type_options.add_argument(
            "--rake",
            action="append_const",
            dest="include_filename_pattern",
            const=r"Rakefile",
            help="Rake")
    target_type_options.add_argument(
            "--r",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.R$|.*\.r$",
            help="R")
    target_type_options.add_argument(
            "--rst",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.rst$|.*\.txt$|.*\.inc$",
            help="ReStructuredText")
    target_type_options.add_argument(
            "--ruby",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.rb$|.*\.rhtml$|.*\.rjs$|.*\.rxml$|.*\.erb$|.*\.rake$|.*\.spec$|Rakefile",
            help="Ruby")
    target_type_options.add_argument(
            "--rust",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.rs$",
            help="Rust")
    target_type_options.add_argument(
            "--sass",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.sass$|.*\.scss$",
            help="Sass")
    target_type_options.add_argument(
            "--scala",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.scala$",
            help="Scala")
    target_type_options.add_argument(
            "--scheme",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.scm$|.*\.ss$",
            help="Scheme")
    target_type_options.add_argument(
            "--shell",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.sh$|.*\.bash$|.*\.csh$|.*\.tcsh$|.*\.ksh$|.*\.zsh$|.*\.fish$",
            help="shell")
    target_type_options.add_argument(
            "--smalltalk",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.st$",
            help="Smalltalk")
    target_type_options.add_argument(
            "--sphinx",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.rst$|.*\.txt$|.*\.inc|conf\.py",
            help="Sphinx")
    target_type_options.add_argument(
            "--sql",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.sql$|.*\.ctl$",
            help="SQL")
    target_type_options.add_argument(
            "--tcl",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.tcl$|.*\.itcl$|.*\.itk$",
            help="TCl")
    target_type_options.add_argument(
            "--tex",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.tex$|.*\.bib$",
            help="TeX")
    target_type_options.add_argument(
            "--tex-all",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.tex$|.*\.cls$|.*\.sty$|.*\.bib$",
            help="TeX")
    target_type_options.add_argument(
            "--tt",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.tt$|.*\.tt2$|.*\.ttml$",
            help="TT")
    target_type_options.add_argument(
            "--vb",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.bas$|.*\.cls$|.*\.frm$|.*\.ctl$|.*\.vb$|.*\.resx$",
            help="VisualBasic")
    target_type_options.add_argument(
            "--verilog",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.v$|.*\.vh$|.*\.sv$",
            help="Verilog")
    target_type_options.add_argument(
            "--vhdl",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.vhd$|.*\.vhdl$",
            help="VHDL")
    target_type_options.add_argument(
            "--vim",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.vim$",
            help="Vim")
    target_type_options.add_argument(
            "--xml",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.xml$|.*\.dtd$|.*\.xsl$|.*\.xslt$|.*\.ent$",
            help="XML")
    target_type_options.add_argument(
            "--yaml",
            action="append_const",
            dest="include_filename_pattern",
            const=r".*\.yaml$|.*\.yml$",
            help="YAML")

    exclude_options_group = parser.add_argument_group("Exclusion Options")
    exclude_options_group.add_argument(
            "-D", "--exclude-dir-patterns",
            action="append",
            metavar="PATTERN",
            dest="dirs_to_exclude",
	    help="Regular expression patterns to be matched to directory "
	    "names(s) to exclude. Multiple path patterns may be specified "
	    "by, e.g.: '-D path1 -D path2 -D path3'.")
    exclude_options_group.add_argument(
            "-F", "--exclude-file-patterns",
            action="append",
            metavar="PATTERN",
            dest="files_to_exclude",
	    help="Regular expression patterns to be matched to filename(s) "
	    "to exclude. Multiple path patterns may be specified by, e.g.: "
	    "'-F path1 -F path2 -F path3'.")
    exclude_options_group.add_argument(
            "--include-gitignore-files",
            action="store_false",
	    help="Do not filter out files in '.gitignore' (by default, "
	    "these are filtered out).")

    action_group_section = parser.add_argument_group("Action Options")
    action_group = action_group_section.add_mutually_exclusive_group()
    action_group.add_argument(
            "-E", "--edit",
            action="store_const",
            dest="action_type",
            const="edit",
	    help="[DEFAULT] Opens file in editor (with editor program "
	    "specified by, in order of resolution, '$FUZZYSNAKE_EDITOR' or "
	    "'$EDITOR').")
    action_group.add_argument(
            "-p", "--print",
            action="store_const",
            dest="action_type",
            const="print",
            help="Prints selected filepath to standard output.")
    action_group.add_argument(
            "-o", "--open",
            action="store_const",
            dest="action_type",
            const="open",
            help="Passes filepath to 'open' command.")
    parser.set_defaults(action_type="edit")

    return parser.parse_args()

if __name__ == '__main__':
    args = build_arg_parser()
    runner = DirRun(args)
    runner.run()
