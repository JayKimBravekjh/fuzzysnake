#!/usr/bin/env python

###############################################################################
##
##  Copyright 2014 Jeet Sukumaran.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
##
## Modified by Jeet Sukumaran from "quickfind"::
##
##      quickfind
##      https://github.com/Refefer/quickfind
##      By Andrew Stanton.
##
################################################################################

"""
Fuzzy-filter and open files for editing from your shell.
"""

import os
import sys
import termios
import heapq
import argparse
import curses
import fcntl
import struct
import fnmatch
import re
import itertools
import collections
try:
    from StringIO import StringIO # Python 2 legacy support: StringIO in this module is the one needed (not io)
except ImportError:
    from io import StringIO # Python 3
try:
    import fsnix.util as util
    walk = util.walk
except ImportError:
    walk = os.walk
if sys.version_info.major >= 3:
    unicode_str = lambda x: str(x)
else:
    unicode_str = lambda x: unicode(x, errors="ignore")

__prog__ = os.path.basename(__file__)
__version__ = "1.0.0"
__description__ = __doc__
__author__ = 'Jeet Sukumaran'
__copyright__ = 'Copyright (C) 2014 Jeet Sukumaran.'

##############################################################################
## Util.py

def truncate_front(line, length=70):
    reduce_amt = len(line) - length
    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line

    reduce_amt += 3 # for the ellipsis
    return '...'+line[reduce_amt:]

def truncate_middle(line, length=70):
    reduce_amt = len(line) - length

    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line

    reduce_amt += 3 # for the ellipsis

    start = (len(line) / 2) - (reduce_amt / 2)
    end = start + reduce_amt
    return "%s...%s" % (line[:start], line[end:])

def rec_dir_up(dir):
    if os.path.isdir(dir):
        while True:
            yield dir
            newdir = os.path.split(dir)[0]
            if newdir == dir: break
            dir = newdir

##############################################################################
## Entry

class Entry(object):

    def __init__(self,
            dirname,
            filename,
            score,
            match_start,
            match_end,
            match_basename_only):
        self.dirname = dirname
        self.filename = filename
        self.score = score
        self.match_basename_only = match_basename_only
        self._match_start_offset = match_start
        self._match_end_offset = match_end

        # TODO: make the follow dynamic attributes
        self.filepath = os.path.join(self.dirname, self.filename)
        if self.match_basename_only:
            self._candidate_start = len(os.path.join(self.dirname, ""))
        else:
            self._candidate_start = 0

    def _get_match_start(self):
        return self._candidate_start + self._match_start_offset
    def _set_match_start(self, v):
        self._match_start_offset = v
    match_start = property(_get_match_start, _set_match_start)

    def _get_match_end(self):
        return self._candidate_start + self._match_end_offset
    def _set_match_end(self, v):
        self._match_end_offset = v
    match_end = property(_get_match_end, _set_match_end)

    def __lt__(self, other):
        return self.score < other.score

##############################################################################
## Searcher.py

class CursesPrinter(object):

    def __init__(self):
        self.querylen = 0

    def init(self):
        self.window = curses.initscr()
        curses.start_color()
        curses.use_default_colors()
        curses.noecho()

        # color for default text
        curses.init_pair(1, -1, -1)
        self.default_color = curses.color_pair(1)

        # color for matched text
        # curses.init_pair(2, -1, -1)
        ## TODO: allow configuration from environmental variable or rc file!
        curses.init_pair(2, curses.COLOR_GREEN, -1)
        self.match_color = curses.color_pair(2) | curses.A_UNDERLINE

    def cleanup(self):
        curses.echo()
        curses.endwin()

    def print_query(self, query):
        q = "$ " + query
        self.querylen = len(q)
        self.window.addstr(0, 0, q)

    def print_item(self, idx, item, is_selected, query):
        self.window.move(1 + idx, 0)
        # length = self.window.getmaxyx()[0]
        length = getDims()[1] # more responsive to window resizing?
        entry = truncate_middle(item.filepath, length)
        if is_selected:
            leader = "> "
            weight = curses.A_REVERSE
        else:
            leader = "  "
            weight = curses.A_NORMAL
        if item.score > 0:
            left = entry[:item.match_start]
            main = entry[item.match_start:item.match_end]
            right = entry[item.match_end:]
            self.window.addstr(leader)
            self.window.addstr(left, self.default_color | weight)
            self.window.addstr(main, self.match_color | weight)
            self.window.addstr(right, self.default_color | weight)
        else:
            self.window.addstr(leader + entry, self.default_color | weight)

    def clear(self):
        self.window.clear()

    def flush(self):
        self.window.move(0, self.querylen)
        self.window.refresh()

class Searcher(object):

    def __init__(self,
            ranker,
            output,
            whitespace_separated_multiquery=False,
            match_basename_only=False,
            pattern_type="fuzzy"):
        self.ranker = ranker
        self.output = output
        self.whitespace_separated_multiquery = whitespace_separated_multiquery
        self.match_basename_only = match_basename_only
        self.pattern_type = pattern_type

    def _getch(self, blocking=True):
        if blocking:
            # self.output.window.timeout(-1)
            self.output.window.nodelay(0)
        else:
            # self.output.window.timeout(100)
            self.output.window.nodelay(1)
        c = self.output.window.getch()
        if blocking: # restore
            # self.output.window.timeout(-1)
            self.output.window.nodelay(0)
        return c

    def _newHeap(self, query, curHeap):
        newHeap = []
        ranker = self.ranker(query=query,
                whitespace_separated_multiquery=self.whitespace_separated_multiquery,
                match_basename_only=self.match_basename_only,
                pattern_type=self.pattern_type)
        for w, item in curHeap:
            try:
                score, match_start, match_end = ranker.rank(item)
            except FuzzyRanker.IncompleteRegularExpressionPatternException:
                return curHeap
            if score:
                item.score = score
                item.match_start = match_start
                item.match_end = match_end
                heapq.heappush(newHeap, (score, item))
            else:
                item.score = 0
                item.match_start = 0
                item.match_end = 0
        return newHeap

    def _topItems(self, heap, N=5):
        h = heap[:]
        items = []
        for _ in range(N):
            if len(h) == 0:
                break
            w, item  = heapq.heappop(h)
            items.append(item)
        return items

    def _loop(self, curHeaps, N):
        heapq.heapify(curHeaps[0])

        cur = ""
        selected = 0
        while True:
            self.output.window.timeout(-1)
            next_char = self._getch(blocking=True)

            # Escape: could be just Escape, could be Ansi escape for
            # arrows
            if next_char == 27:

                # just escape? try non-blocking read to see if
                # any other characters
                next_char = self._getch(blocking=False)
                if next_char == -1:
                    raise KeyboardInterrupt()

                # other characters available
                # assuming arrow-key, we discard
                # the current and read the next
                next_char = self._getch(blocking=True)

                # Up/down
                if next_char == 66:
                    itemsShown = min(N, len(curHeaps[-1])) - 1
                    selected = min(itemsShown, selected + 1)
                elif next_char == 65:
                    selected = max(0, selected - 1)

            else :
                # Selected
                if next_char == 10 or next_char == 13: # enter
                    h = curHeaps[-1]
                    for _ in range(selected):
                        if not h: break
                        heapq.heappop(h)
                    return heapq.heappop(h)[1] if h else None

                selected = 0

                # Escape code
                if next_char in (3, 4, 28, 26):
                    raise KeyboardInterrupt()

                # Delete/backspace
                if next_char in (8, 127):
                    if cur != "":
                        cur = cur[:-1]
                        curHeaps.pop()
                else:
                    try:
                        cur += chr(next_char)
                        curHeaps.append(self._newHeap(cur, curHeaps[-1]))
                    except ValueError:
                        pass

            self._echo(cur, curHeaps[-1], selected, N)

    def _echo(self, cur, heap, selected, N):
        self.output.clear()
        self.output.print_query(cur)
        for i, item in enumerate(self._topItems(heap, N)):
            self.output.print_item(i, item, i==selected, cur)
        self.output.flush()


    def run(self, items, rows):
        self.output.init()
        try:
            heap = [(0, i) for i in items]
            heap.sort()
            self._echo("", heap, 0, N=rows)
            return self._loop([heap], rows)
        finally:
            self.output.cleanup()

##############################################################################
## DirectorySource.py

File = collections.namedtuple("File", "dir,name,sname")
class DirectorySource(object):

    def __init__(self, dir=".", ignore_directories=True, ignore_files=True, git_ignore=True):
        self.ignore_directories = ignore_directories
        self.ignore_files = ignore_files
        self.git_ignore = git_ignore
        self.startDir = dir
        self.filters = []
        if git_ignore:
            self.find_parent_gis()

    def find_parent_gis(self):
        dirs = rec_dir_up(self.startDir)
        next(dirs)
        # dirs.next()
        for dirname in dirs:
            pgi = os.path.join(dirname, '.gitignore')
            if os.path.isfile(pgi):
                self.filters.append(GitIgnoreFilter(dirname, '.gitignore'))
        self.filters.reverse()

    def fetch(self):
        lst = []
        for dirname, dirs, filenames in walk(self.startDir):
            names = []
            if not self.ignore_files:
                names = filenames
            if not self.ignore_directories:
                names.extend(dirs)

            if self.git_ignore and '.gitignore' in filenames:
                gif = GitIgnoreFilter(dirname, '.gitignore')
                self.filters.append((dirname, gif))

            while self.filters:
                path, _ = self.filters[-1]
                if dirname.startswith(path): break
                self.filters.pop()

            fltr = None
            if self.filters:
                fltr = self.filters[-1][1]

            if fltr is None:
                files = (File(dirname, name, name.lower()) for name in names)
            else:
                files = (File(dirname, name, name.lower())
                        for name in names if fltr(name, dirname))
            lst.extend(files)

            # have to delete the names manually
            if fltr is not None:
                for i in range(len(dirs) - 1, -1, -1):
                    if not fltr(dirs[i], dirname):
                        del dirs[i]

        return lst

class GitIgnoreFilter(object):
    # Optimization
    lastdir = None
    last_path_filter = None

    globchars = re.compile('[*\[\]?]')
    def __init__(self, dirname, filename):
        self.dirname = dirname
        self.fn = os.path.join(dirname, filename)
        path_filters = []
        glob_filters = []
        exact_filters = set(['.git'])
        with open(self.fn) as f:
            gc = self.globchars
            for fn in f:
                if fn.startswith('#'):
                    continue

                fn = fn.strip()
                if fn.startswith('/'):
                    path_filters.append(fn)
                elif gc.search(fn) is not None:
                    glob_filters.append(fnmatch.translate(fn.strip()))
                else:
                    exact_filters.add(fn)

        if glob_filters:
            self.glob_filters = [re.compile('|'.join(glob_filters))]
        else:
            self.glob_filters = []

        self.exact_filters = exact_filters
        self.path_filters = self.setup_path_filters(path_filters)

    def setup_path_filters(self, path_filters):
        # We can currently glob on only filename positions
        dirmaps = {}
        for pf in path_filters:
            while pf.endswith('/'):
                pf = pf[:-1]

            dirname, basename = os.path.split(pf)
            dm = os.path.join(self.dirname, dirname.lstrip('/'))
            glob = fnmatch.translate(basename.strip())
            if dm in dirmaps:
                dirmaps[dm].append(glob)
            else:
                dirmaps[dm] = [glob]

        # Build glob maps
        for k in dirmaps.keys():
            vs = dirmaps[k]
            dirmaps[k] = re.compile('|'.join(vs))

        return dirmaps

    def __call__(self, fn, dirname):
        # check exact
        if fn in self.exact_filters:
            return False
        # Check global globs
        for f in self.glob_filters:
            if f.match(fn) is not None:
                return False

        lpf = self.path_filters.get(dirname)

        # check path dependent globs
        if lpf is not None and lpf.match(fn) is not None:
            return False

        return True

class FuzzyRanker(object):

    class IncompleteRegularExpressionPatternException(Exception):
        pass

    def match_and_score(query, s, pattern_type):
        if pattern_type == "fuzzy":
            pattern = '.*?'.join(map(re.escape, list(query)))
        elif pattern_type == "strict":
            pattern = ''.join(map(re.escape, list(query)))
        elif pattern_type == "regexp":
            pattern = query
        else:
            raise TypeError("Unrecognized pattern type: '{}'".format(pattern_type))
        try:
            match = re.search(pattern, s, re.I)
        except re.error:
            if pattern_type == "regexp":
                raise FuzzyRanker.IncompleteRegularExpressionPatternException()
        if match is None:
            result = 0
        else:
            # return 100 / ((1+match.start()) * (match.end()-match.start()+1))
            result = 1000.0 / ((1 + match.start()) * (match.end() - match.start() + 1))
        return match, result
    match_and_score = staticmethod(match_and_score)

    def __init__(self,
            query,
            whitespace_separated_multiquery=False,
            match_basename_only=False,
            pattern_type="fuzzy"):
        self.whitespace_separated_multiquery = whitespace_separated_multiquery
        self.match_basename_only =match_basename_only
        self.weight_f = lambda f: f.dirname.count(os.sep) ** 0.5
        self.qs = query.lower()
        if self.whitespace_separated_multiquery:
            self.qs = self.qs.split()
        else:
            self.qs = [self.qs]
        self.pattern_type = pattern_type

    def rank(self, item):
        if self.match_basename_only:
            part = item.filename
        else:
            part = item.filepath
        agg_score = 0.0
        match_start = len(part)
        match_end = -1
        for q in self.qs:
            match, score = self.match_and_score(q, part, self.pattern_type)
            if score is None or score == 0:
                # return None, None, None
                return None, None, None
            if score is not None:
                match_start = min(match_start, match.start())
                match_end = max(match_end, match.end())
                agg_score += score
        # return agg_score + self.weight_f(item), match_start, match_end
        return agg_score, match_start, match_end

##############################################################################
## Console.py

def getDims():
    env = os.environ
    def ioctl_GWINSZ(fd):
        try:
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
        except:
            return
        return cr

    return ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2) or (25, 80)

##############################################################################
## Main Code

class Runner(object):
    def __init__(self, args):
        self.rows, self.columns = getDims()
        self.args = args
        self.editor_path = os.environ.get("FUZZYSNAKE_EDITOR", os.environ.get("EDITOR", "vi"))

    def find(self):
        raise NotImplementedError()

    def run(self):
        filename = self.find()
        if filename is not None:
            if args.action_type == "edit":
                try:
                    os.execvp(self.editor_path, [self.editor_path, filename])
                except:
                    sys.stderr.write("Failed to execute: os.execvp('{}', ['{}', {}])\n".format(self.editor_path, self.editor_path, filename))
                    sys.exit(1)
            elif args.action_type == "print":
                sys.stdout.write(filename)
                sys.stdout.write("\n")
                sys.exit(0)
            elif args.action_type == "open":
                try:
                    os.execvp('open', ['open', filename])
                except:
                    sys.stderr.write("Failed to execute: os.execvp('open', ['open', {}])\n".format(filename))
                    sys.exit(1)
            else:
                sys.exit("Unrecognized action: '{}'".format(args.action_type))

class DirRun(Runner):

    def find(self):

        git_ignore = self.args.include_gitignore_files
        if self.args.target_type == 'all':
            ds = DirectorySource(ignore_directories=False,
                    ignore_files=False, git_ignore=git_ignore)
        elif self.args.target_type == 'files':
            ds = DirectorySource(ignore_files=False, git_ignore=git_ignore)
        else:
            ds = DirectorySource(ignore_directories=False, git_ignore=git_ignore)

        file_items = ds.fetch()
        items = []
        for item in file_items:
            entry = Entry(dirname=item.dir,
                    filename=item.name,
                    score=0,
                    match_start=0,
                    match_end=-1,
                    match_basename_only=self.args.basename_only_match)
            items.append(entry)

        ranker = FuzzyRanker
        s = Searcher(ranker=ranker,
                output=CursesPrinter(),
                whitespace_separated_multiquery=self.args.multi_query,
                match_basename_only=self.args.basename_only_match,
                pattern_type=self.args.pattern_type,
                )
        try:
            found = s.run(items, self.rows - 3)
        except KeyboardInterrupt:
            sys.exit(0)

        if found is not None:
            found = os.path.join(found.dirname, found.filename)
        return found

def build_arg_parser():
    parser = argparse.ArgumentParser(description=__description__)
    parser.add_argument("--version", action="version", version="FuzzySnake " + __version__)

    query_type_section = parser.add_argument_group("Query Type")
    query_type_section.add_argument("-m", "--multi-query",
            action="store_true", help="Multiple query patterns can be entered, with each pattern being separated by whitespace (defaults to entire expression being treated as single pattern).")
    query_type_section.add_argument("-b", "--basename-only-match",
            action="store_true", help="Restrict match to the basename or tail of the path only (by default, entire path will be matched).")
    query_type_section.add_argument("-g", "--include-gitignore-files",
            action="store_false", help="Do not filter out files in '.gitignore'.")

    pattern_type_section = parser.add_argument_group("Pattern Type")
    pattern_type_group = pattern_type_section.add_mutually_exclusive_group()
    pattern_type_group.add_argument("-f", "--fuzzy",
            action="store_const",
            dest="pattern_type",
            const="fuzzy",
            help="[DEFAULT] Treat patterns as normal text (i.e., not a regular expression), with fuzzy matching.")
    pattern_type_group.add_argument("-s", "--strict",
            action="store_const",
            dest="pattern_type",
            const="strict",
            help="Treat patterns as normal text (i.e., not a regular expression), with strict matching")
    pattern_type_group.add_argument("-e", "--regexp",
            action="store_const",
            dest="pattern_type",
            const="regexp",
            help="Treat patterns entered as (Python-dialect) regular expressions.")
    parser.set_defaults(pattern_type="fuzzy")

    target_group_section = parser.add_argument_group("Search Target Type")
    target_group = target_group_section.add_mutually_exclusive_group()
    target_group.add_argument("-F", "--files-only", action="store_const", dest="target_type", const="files",
            help="[DEFAULT] Search for files only.")
    target_group.add_argument("-d", "--dirs-only", action="store_const", dest="target_type", const="dirs",
            help="Search for directories only.")
    target_group.add_argument("-a", "--all", action="store_const", dest="target_type", const="all",
            help="Search for both directories and filess.")
    parser.set_defaults(target_type="files")

    action_group_section = parser.add_argument_group("Action Type")
    action_group = action_group_section.add_mutually_exclusive_group()
    action_group.add_argument("-E", "--edit",
            action="store_const",
            dest="action_type",
            const="edit",
            help="[DEFAULT] Opens file in editor (with editor program specified by, in order of resolution, '$FUZZYSNAKE_EDITOR' or '$EDITOR').")
    action_group.add_argument("-p", "--print",
            action="store_const",
            dest="action_type",
            const="print",
            help="Prints selected filepath to standard output.")
    action_group.add_argument("-o", "--open",
            action="store_const",
            dest="action_type",
            const="open",
            help="Passes filepath to 'open' command.")

    return parser.parse_args()

if __name__ == '__main__':
    args = build_arg_parser()
    runner = DirRun(args)
    runner.run()
