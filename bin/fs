#!/usr/bin/env python

###############################################################################
##
##  Copyright 2014 Jeet Sukumaran.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
##
## Modified by Jeet Sukumaran from "quickfind"::
##
##      quickfind
##      https://github.com/Refefer/quickfind
##      By Andrew Stanton.
##
################################################################################

"""
List, filter, and open files for editing from your shell, using dynamic
matching of fuzzy or regular-expression of entered patterns.
"""

import os
import sys
import termios
import heapq
import argparse
import curses
import fcntl
import struct
import fnmatch
import re
import itertools
import collections
try:
    from StringIO import StringIO # Python 2 legacy support: StringIO in this module is the one needed (not io)
except ImportError:
    from io import StringIO # Python 3
try:
    import fsnix.util as util
    walk = util.walk
except ImportError:
    walk = os.walk
if sys.version_info.major >= 3:
    unicode_str = lambda x: str(x)
else:
    unicode_str = lambda x: unicode(x, errors="ignore")

__prog__ = os.path.basename(__file__)
__version__ = "1.0.0"
__description__ = __doc__
__author__ = 'Jeet Sukumaran'
__copyright__ = 'Copyright (C) 2014 Jeet Sukumaran.'

##############################################################################
## Util.py

def truncate_front(line, length=70):
    reduce_amt = len(line) - length
    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line

    reduce_amt += 3 # for the ellipsis
    return '...'+line[reduce_amt:]

def truncate_middle(line, length=70):
    reduce_amt = len(line) - length

    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line

    reduce_amt += 3 # for the ellipsis

    start = (len(line) / 2) - (reduce_amt / 2)
    end = start + reduce_amt
    return "%s...%s" % (line[:start], line[end:])

def rec_dir_up(dir):
    if os.path.isdir(dir):
        while True:
            yield dir
            newdir = os.path.split(dir)[0]
            if newdir == dir: break
            dir = newdir

##############################################################################
## Entry

class Entry(object):

    def __init__(self,
            dirname,
            filename,
            score,
            match_start,
            match_end,
            match_basename_only):
        self.dirname = dirname
        self.filename = filename
        self.score = score
        self.match_basename_only = match_basename_only
        self._match_start_offset = match_start
        self._match_end_offset = match_end

    def _get_filepath(self):
        return os.path.join(self.dirname, self.filename)
    filepath = property(_get_filepath)

    def _start_of_basename_in_filepath(self):
        return len(os.path.join(self.dirname, ""))
    start_of_basename_in_filepath = property(_start_of_basename_in_filepath)

    def _get_match_start(self):
        if self.match_basename_only:
            return self.start_of_basename_in_filepath + self._match_start_offset
        else:
            return self._match_start_offset
    def _set_match_start(self, v):
        self._match_start_offset = v
    match_start = property(_get_match_start, _set_match_start)

    def _get_match_end(self):
        if self.match_basename_only:
            return self.start_of_basename_in_filepath + self._match_end_offset
        else:
            return self._match_end_offset
    def _set_match_end(self, v):
        self._match_end_offset = v
    match_end = property(_get_match_end, _set_match_end)

    def __lt__(self, other):
        return self.score < other.score

##############################################################################
## Searcher.py

class CursesPrinter(object):

    def __init__(self):
        self.querylen = 0

    def init(self):
        #################
        # for debugging #
        # raise Exception()
        #################
        self.window = curses.initscr()
        curses.start_color()
        curses.use_default_colors()
        curses.noecho()

        # color for default text
        curses.init_pair(1, -1, -1)
        self.default_color = curses.color_pair(1)

        # color for matched text
        # curses.init_pair(2, -1, -1)
        ## TODO: allow configuration from environmental variable or rc file!
        curses.init_pair(2, curses.COLOR_GREEN, -1)
        self.match_color = curses.color_pair(2) | curses.A_UNDERLINE

    def cleanup(self):
        curses.echo()
        curses.endwin()

    def print_query(self, query):
        q = "$ " + query
        self.querylen = len(q)
        self.window.addstr(0, 0, q)

    def print_item(self, idx, item, is_selected, query):
        self.window.move(1 + idx, 0)
        # length = self.window.getmaxyx()[0]
        length = getDims()[1] # more responsive to window resizing?
        entry = truncate_middle(item.filepath, length)
        if is_selected:
            leader = "> "
            weight = curses.A_REVERSE
        else:
            leader = "  "
            weight = curses.A_NORMAL
        if item.score > 0:
            left = entry[:item.match_start]
            main = entry[item.match_start:item.match_end]
            right = entry[item.match_end:]
            self.window.addstr(leader)
            self.window.addstr(left, self.default_color | weight)
            self.window.addstr(main, self.match_color | weight)
            self.window.addstr(right, self.default_color | weight)
        else:
            self.window.addstr(leader + entry, self.default_color | weight)

    def clear(self):
        self.window.clear()

    def flush(self):
        self.window.move(0, self.querylen)
        self.window.refresh()

    def move(self, y, x):
        self.window.move(y, x)
        self.window.refresh()

class Searcher(object):

    def __init__(self,
            ranker,
            output,
            whitespace_separated_multiquery=False,
            match_basename_only=False,
            match_type="fuzzy"):
        self.ranker = ranker
        self.output = output
        self.whitespace_separated_multiquery = whitespace_separated_multiquery
        self.match_basename_only = match_basename_only
        self.match_type = match_type

    def _getch(self, blocking=True):
        if blocking:
            # self.output.window.timeout(-1)
            self.output.window.nodelay(0)
        else:
            # self.output.window.timeout(100)
            self.output.window.nodelay(1)
        c = self.output.window.getch()
        if blocking: # restore
            # self.output.window.timeout(-1)
            self.output.window.nodelay(0)
        return c

    def _newHeap(self, query, curHeap):
        newHeap = []
        ranker = self.ranker(query=query,
                whitespace_separated_multiquery=self.whitespace_separated_multiquery,
                match_basename_only=self.match_basename_only,
                match_type=self.match_type)
        for w, item in curHeap:
            item.match_basename_only = self.match_basename_only # needs to be updated here
            try:
                score, match_start, match_end = ranker.rank(item)
            except FuzzyRanker.IncompleteRegularExpressionPatternException:
                return curHeap
            if score:
                item.score = score
                item.match_start = match_start
                item.match_end = match_end
                heapq.heappush(newHeap, (score, item))
            else:
                item.score = 0
                item.match_start = 0
                item.match_end = 0
        return newHeap

    def _topItems(self, heap, N=5):
        h = heap[:]
        items = []
        for _ in range(N):
            if len(h) == 0:
                break
            w, item  = heapq.heappop(h)
            items.append(item)
        return items

    def _reset_search(self, current_query, current_heaps):
        current_heaps = current_heaps[:1]
        old_query = current_query
        current_query = ""
        for ch in old_query:
            current_query += ch
            current_heaps.append(self._newHeap(current_query, current_heaps[-1]))
        return current_heaps

    def _loop(self, current_heaps, N):
        heapq.heapify(current_heaps[0])

        current_query = ""
        selected = 0

        while True:
            self.output.window.timeout(-1)
            next_char = self._getch(blocking=True)

            # Escape: could be just Escape, could be Ansi escape for
            # arrows
            if next_char == 27:

                # just escape? try non-blocking read to see if
                # any other characters
                next_char = self._getch(blocking=False)
                if next_char == -1:
                    raise KeyboardInterrupt()

                # other characters available
                # assuming arrow-key, we discard
                # the current and read the next
                next_char = self._getch(blocking=True)

                # Up/down
                if next_char == 66:
                    itemsShown = min(N, len(current_heaps[-1])) - 1
                    selected = min(itemsShown, selected + 1)
                elif next_char == 65:
                    selected = max(0, selected - 1)
            elif next_char == 14:
                # <CTRL-N>: Next (Down)
                itemsShown = min(N, len(current_heaps[-1])) - 1
                selected = min(itemsShown, selected + 1)
            elif next_char == 16:
                # <CTRL-P>: Previous (Up)
                selected = max(0, selected - 1)
            elif next_char == 2:
                # <CTRL-B>: Cycle full-path vs. basename matching
                self.match_basename_only = not self.match_basename_only
                current_heaps = self._reset_search(current_query, current_heaps)
            elif next_char == 6:
                # <CTRL-F>: Fuzzy-matching mode
                self.match_type = "fuzzy"
                current_heaps = self._reset_search(current_query, current_heaps)
            elif next_char == 5:
                # <CTRL-E>: Regular-expression matching mode
                self.match_type = "regexp"
                current_heaps = self._reset_search(current_query, current_heaps)
            elif next_char == 18:
                # <CTRL-L>: Literal or raw matching mode
                self.match_type = "literal"
                current_heaps = self._reset_search(current_query, current_heaps)
            elif next_char == 23:
                # <CTRL-W>: Toggle whitespace-separated multi-search
                self.whitespace_separated_multiquery = not self.whitespace_separated_multiquery
                current_heaps = self._reset_search(current_query, current_heaps)
            else:
                # Selected
                if next_char == 10 or next_char == 13: # enter
                    h = current_heaps[-1]
                    for _ in range(selected):
                        if not h: break
                        heapq.heappop(h)
                    return heapq.heappop(h)[1] if h else None
                selected = 0
                if next_char in (3, 4, 26, 28):
                    # <CTRL-C>, <CTRL-D>, <CTRL-Z>, etc.
                    raise KeyboardInterrupt()
                elif next_char in (8, 127):
                    # Delete/backspace
                    if current_query != "":
                        current_query = current_query[:-1]
                        current_heaps.pop()
                else:
                    try:
                        current_query += chr(next_char)
                        current_heaps.append(self._newHeap(current_query, current_heaps[-1]))
                    except ValueError:
                        pass
            self._echo(current_query, current_heaps[-1], selected, N)

    def _echo(self, current_query, heap, selected, N):
        self.output.clear()
        self.output.print_query(current_query)
        for i, item in enumerate(self._topItems(heap, N)):
            self.output.print_item(i, item, i==selected, current_query)
        self.output.flush()

    def run(self, items, rows):
        self.output.init()
        try:
            heap = [(i.score, i) for i in items]
            heap.sort()
            self._echo("", heap, 0, N=rows)
            return self._loop([heap], rows)
        finally:
            self.output.cleanup()

##############################################################################
## DirectorySource.py

class DirectorySource(object):

    def __init__(self, ignore_directories=True, ignore_files=True, ignore_gitignores=True):
        self.ignore_directories = ignore_directories
        self.ignore_files = ignore_files
        self.ignore_gitignores = ignore_gitignores

    def find_parent_gis(self, start_dir):
        gitignore_filters = []
        dirs = rec_dir_up(start_dir)
        next(dirs)
        # dirs.next()
        for dirname in dirs:
            pgi = os.path.join(dirname, '.gitignore')
            if os.path.isfile(pgi):
                gitignore_filters.append(GitIgnoreFilter(dirname, '.gitignore'))
        gitignore_filters.reverse()
        return gitignore_filters

    def fetch(self, start_dir="."):
        gitignore_filters = []
        all_filters = []
        if self.ignore_gitignores:
            self.find_parent_gis(start_dir)
        lst = []
        for dirname, dirs, filenames in walk(start_dir):
            names = []
            if not self.ignore_files:
                names = filenames
            if not self.ignore_directories:
                names.extend(dirs)
            if self.ignore_gitignores and '.gitignore' in filenames:
                gif = GitIgnoreFilter(dirname, '.gitignore')
                gitignore_filters.append((dirname, gif))
            all_filters.extend(gitignore_filters)
            while all_filters:
                path, filter_obj = all_filters[-1]
                if dirname.startswith(path):
                    break
                all_filters.pop()

            fltr = None
            if all_filters:
                fltr = all_filters[-1][1]

            for name in names:
                if fltr is None or fltr(name, dirname):
                    entry = Entry(dirname=dirname,
                            filename=name,
                            score=len(lst),
                            match_start=0,
                            match_end=0,
                            match_basename_only=False)
                    lst.append(entry)
            # if fltr is None:
            #     files = (File(dirname, name, name.lower()) for name in names)
            # else:
            #     files = (File(dirname, name, name.lower())
            #             for name in names if fltr(name, dirname))
            # lst.extend(files)

            # have to delete the names manually
            if fltr is not None:
                for i in range(len(dirs) - 1, -1, -1):
                    if not fltr(dirs[i], dirname):
                        del dirs[i]
        return lst

class GitIgnoreFilter(object):
    # Optimization
    lastdir = None
    last_path_filter = None

    globchars = re.compile('[*\[\]?]')
    def __init__(self, dirname, filename):
        self.dirname = dirname
        self.fn = os.path.join(dirname, filename)
        path_filters = []
        glob_filters = []
        exact_filters = set(['.git'])
        with open(self.fn) as f:
            gc = self.globchars
            for fn in f:
                if fn.startswith('#'):
                    continue
                fn = fn.strip()
                if fn.startswith('/'):
                    path_filters.append(fn)
                elif gc.search(fn) is not None:
                    glob_filters.append(fnmatch.translate(fn.strip()))
                else:
                    exact_filters.add(fn)

        if glob_filters:
            self.glob_filters = [re.compile('|'.join(glob_filters))]
        else:
            self.glob_filters = []

        self.exact_filters = exact_filters
        self.path_filters = self.setup_path_filters(path_filters)

    def setup_path_filters(self, path_filters):
        # We can currently glob on only filename positions
        dirmaps = {}
        for pf in path_filters:
            while pf.endswith('/'):
                pf = pf[:-1]

            dirname, basename = os.path.split(pf)
            dm = os.path.join(self.dirname, dirname.lstrip('/'))
            glob = fnmatch.translate(basename.strip())
            if dm in dirmaps:
                dirmaps[dm].append(glob)
            else:
                dirmaps[dm] = [glob]

        # Build glob maps
        for k in dirmaps.keys():
            vs = dirmaps[k]
            dirmaps[k] = re.compile('|'.join(vs))

        return dirmaps

    def __call__(self, fn, dirname):
        # check exact
        if fn in self.exact_filters:
            return False
        # Check global globs
        for f in self.glob_filters:
            if f.match(os.path.join(dirname, fn)) is not None:
                return False
            if f.match(fn) is not None:
                return False

        lpf = self.path_filters.get(dirname)

        # check path dependent globs
        if lpf is not None and lpf.match(fn) is not None:
            return False

        return True

class FuzzyRanker(object):

    class IncompleteRegularExpressionPatternException(Exception):
        pass

    def match_and_score(query, s, match_type):
        if match_type == "fuzzy":
            pattern = '.*?'.join(map(re.escape, list(query)))
        elif match_type == "literal":
            pattern = ''.join(map(re.escape, list(query)))
        elif match_type == "regexp":
            pattern = query
        else:
            raise TypeError("Unrecognized pattern type: '{}'".format(match_type))
        try:
            match = re.search(pattern, s, re.I)
        except re.error:
            if match_type == "regexp":
                raise FuzzyRanker.IncompleteRegularExpressionPatternException()
        if match is None:
            result = 0
        else:
            # return 100 / ((1+match.start()) * (match.end()-match.start()+1))
            result = 1000.0 / ((1 + match.start()) * (match.end() - match.start() + 1))
        return match, result
    match_and_score = staticmethod(match_and_score)

    def __init__(self,
            query,
            whitespace_separated_multiquery=False,
            match_basename_only=False,
            match_type="fuzzy"):
        self.whitespace_separated_multiquery = whitespace_separated_multiquery
        self.match_basename_only =match_basename_only
        self.weight_f = lambda f: f.dirname.count(os.sep) ** 0.5
        self.qs = query.lower()
        if self.whitespace_separated_multiquery:
            self.qs = self.qs.split()
        else:
            self.qs = [self.qs]
        self.match_type = match_type

    def rank(self, item):
        if self.match_basename_only:
            part = item.filename
        else:
            part = item.filepath
        agg_score = 0.0
        match_start = len(part)
        match_end = -1
        for q in self.qs:
            match, score = self.match_and_score(q, part, self.match_type)
            if score is None or score == 0:
                # return None, None, None
                return None, None, None
            if score is not None:
                match_start = min(match_start, match.start())
                match_end = max(match_end, match.end())
                agg_score += score
        # return agg_score + self.weight_f(item), match_start, match_end
        return agg_score, match_start, match_end

##############################################################################
## Console.py

def getDims():
    env = os.environ
    def ioctl_GWINSZ(fd):
        try:
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
        except:
            return
        return cr

    return ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2) or (25, 80)

##############################################################################
## Main Code

class Runner(object):
    def __init__(self, args):
        self.rows, self.columns = getDims()
        self.args = args
        self.editor_path = os.environ.get("FUZZYSNAKE_EDITOR", os.environ.get("EDITOR", "vi"))

    def find(self):
        raise NotImplementedError()

    def run(self):
        filename = self.find()
        if filename is not None:
            if args.action_type == "edit":
                try:
                    os.execvp(self.editor_path, [self.editor_path, filename])
                except:
                    sys.stderr.write("Failed to execute: os.execvp('{}', ['{}', {}])\n".format(self.editor_path, self.editor_path, filename))
                    sys.exit(1)
            elif args.action_type == "print":
                sys.stdout.write(filename)
                sys.stdout.write("\n")
                sys.exit(0)
            elif args.action_type == "open":
                try:
                    os.execvp('open', ['open', filename])
                except:
                    sys.stderr.write("Failed to execute: os.execvp('open', ['open', {}])\n".format(filename))
                    sys.exit(1)
            else:
                sys.exit("Unrecognized action: '{}'".format(args.action_type))

class DirRun(Runner):

    def find(self):
        ignore_gitignores = self.args.include_gitignore_files
        if self.args.target_type == 'all':
            ds = DirectorySource(ignore_directories=False,
                    ignore_files=False, ignore_gitignores=ignore_gitignores)
        elif self.args.target_type == 'files':
            ds = DirectorySource(ignore_files=False, ignore_gitignores=ignore_gitignores)
        else:
            ds = DirectorySource(ignore_directories=False, ignore_gitignores=ignore_gitignores)
        paths = self.args.paths
        if not paths:
            paths = ["."]
        items = []
        for path in paths:
            items.extend( ds.fetch(path) )
        ranker = FuzzyRanker
        s = Searcher(ranker=ranker,
                output=CursesPrinter(),
                whitespace_separated_multiquery=self.args.multi_pattern,
                match_basename_only=self.args.basename_only_match,
                match_type=self.args.match_type,
                )
        try:
            found = s.run(items, self.rows - 3)
        except KeyboardInterrupt:
            sys.exit(0)

        if found is not None:
            found = os.path.join(found.dirname, found.filename)
        return found

def build_arg_parser():
    parser = argparse.ArgumentParser(description=__description__)
    parser.add_argument("--version", action="version", version="FuzzySnake " + __version__)
    parser.add_argument("paths",
            metavar="DIR",
            nargs="*",
            help="Top-level path(s) to search. Defaults to current directory.")
    query_options_section = parser.add_argument_group("Query Options")
    query_options_section.add_argument("-m", "--multi-pattern",
            action="store_true", help="Whitespace-separated multiple-queries: whitespaces in the query will be treated as separators for query terms, allowing multiple query terms to be used simultaneosly. If not specified, defaults to entire expression being treated as single pattern. Use `<CTRL-W>` to toggle this option on and off during the search.")
    query_options_section.add_argument("-b", "--basename-only-match",
            action="store_true", help="Restrict match to the basename or tail of the path only (by default, entire path will be matched). Use `<CTRL-B>` to toggle this option on and off during the search.")
    query_options_section.add_argument("-g", "--include-gitignore-files",
            action="store_false", help="Do not filter out files in '.gitignore'.")

    match_type_section = parser.add_argument_group("Matching Options")
    match_type_group = match_type_section.add_mutually_exclusive_group()
    match_type_group.add_argument("-f", "--fuzzy",
            action="store_const",
            dest="match_type",
            const="fuzzy",
            help="[DEFAULT] Fuzzy-matching mode: patterns are matched on character-by-character basis in the same order as given, but not necessarily consecutively. You can force selection of this mode during the search by typing `<CTRL-R>`.")
    match_type_group.add_argument("-e", "--regexp",
            action="store_const",
            dest="match_type",
            const="regexp",
            help="Regular-expression mode: patterns are matched as full (Python) regular expression patterns. You can force selection of this mode during the search by typing `<CTRL-E>`.")
    match_type_group.add_argument("-l", "--literal",
            action="store_const",
            dest="match_type",
            const="literal",
            help="Literal-matching mode: patterns are matched exactly as given. You can force selection of this mode during the search by typing `<CTRL-L>`.")
    parser.set_defaults(match_type="fuzzy")

    target_group_section = parser.add_argument_group("Target Options")
    target_group = target_group_section.add_mutually_exclusive_group()
    target_group.add_argument("-F", "--files-only", action="store_const", dest="target_type", const="files",
            help="[DEFAULT] Search for files only.")
    target_group.add_argument("-d", "--dirs-only", action="store_const", dest="target_type", const="dirs",
            help="Search for directories only.")
    target_group.add_argument("-a", "--all", action="store_const", dest="target_type", const="all",
            help="Search for both directories and filess.")
    parser.set_defaults(target_type="files")

    action_group_section = parser.add_argument_group("Action Options")
    action_group = action_group_section.add_mutually_exclusive_group()
    action_group.add_argument("-E", "--edit",
            action="store_const",
            dest="action_type",
            const="edit",
            help="[DEFAULT] Opens file in editor (with editor program specified by, in order of resolution, '$FUZZYSNAKE_EDITOR' or '$EDITOR').")
    action_group.add_argument("-p", "--print",
            action="store_const",
            dest="action_type",
            const="print",
            help="Prints selected filepath to standard output.")
    action_group.add_argument("-o", "--open",
            action="store_const",
            dest="action_type",
            const="open",
            help="Passes filepath to 'open' command.")
    parser.set_defaults(action_type="edit")

    return parser.parse_args()

if __name__ == '__main__':
    args = build_arg_parser()
    runner = DirRun(args)
    runner.run()
