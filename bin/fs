#!/usr/bin/env python

###############################################################################
##
##  Copyright 2014 Jeet Sukumaran.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
##
## Modified by Jeet Sukumaran from "quickfind"::
##
##      quickfind
##      https://github.com/Refefer/quickfind
##      By Andrew Stanton.
##
################################################################################

"""
Fuzzy-filter and open files for editing from your shell.
"""

import os
import sys
import termios
import heapq
import argparse
import curses
import functools
import fcntl
import struct
import fnmatch
import re
import itertools
import collections
try:
    from StringIO import StringIO # Python 2 legacy support: StringIO in this module is the one needed (not io)
except ImportError:
    from io import StringIO # Python 3
try:
    import fsnix.util as util
    walk = util.walk
except ImportError:
    walk = os.walk
if sys.version_info.major >= 3:
    unicode_str = lambda x: str(x)
else:
    unicode_str = lambda x: unicode(x)

__prog__ = os.path.basename(__file__)
__version__ = "1.0.0"
__description__ = __doc__
__author__ = 'Jeet Sukumaran'
__copyright__ = 'Copyright (C) 2014 Jeet Sukumaran.'

##############################################################################
## Util.py

def truncate_front(line, length=70):
    reduce_amt = len(line) - length
    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line

    reduce_amt += 3 # for the ellipsis
    return '...'+line[reduce_amt:]

def truncate_middle(line, length=70):
    reduce_amt = len(line) - length

    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line

    reduce_amt += 3 # for the ellipsis

    start = (len(line) / 2) - (reduce_amt / 2)
    end = start + reduce_amt
    return "%s...%s" % (line[:start], line[end:])

def rec_dir_up(dir):
    if os.path.isdir(dir):
        while True:
            yield dir
            newdir = os.path.split(dir)[0]
            if newdir == dir: break
            dir = newdir

def highlight(v, query, color="green"):
    i = v.lower().rfind(query.lower())
    if query and i > -1:
        left = v[:i]
        lq = len(query)
        highlight = v[i:i+lq]
        right = v[i+lq:]
        return [ left, CString(highlight, color), right ]

    return [v]

##############################################################################
## Searcher.py

class CursesPrinter(object):

    def __init__(self, printf):
        self.printf = printf
        self.querylen = 0

    def init(self):
        self.window = curses.initscr()
        curses.start_color()
        curses.use_default_colors()
        curses.noecho()

    def cleanup(self):
        curses.echo()
        curses.endwin()

    def printQuery(self, query):
        q = "$ " + query
        self.querylen = len(q)
        self.window.addstr(0, 0, q)

    def printItem(self, idx, item, selected, query):
        flags = curses.A_BOLD if selected else curses.A_NORMAL
        self.window.move(1 + idx, 0)
        for t in self.convert(self.printf(item, query)):
            if not t.text:
                continue
            if t.fcolor == t.bcolor == -1:
                self.window.addstr(t.text, t.weight | flags)
            else:
                curses.init_pair(1, t.fcolor, t.bcolor)
                self.window.addstr(t.text, curses.color_pair(1) | t.weight | flags)

    def convert(self, text):
        if not isinstance(text, list):
            text = [text]

        r = []
        for t in text:
            r.append(t if isinstance(t, CString) else CString(t))

        return r

    def clear(self):
        self.window.clear()

    def flush(self):
        self.window.move(0, self.querylen)
        self.window.refresh()

class CString(object):
    __slots__ = ('text', 'fcolor', 'bcolor', "weight")

    colors = {
        "default": -1,
        "black": curses.COLOR_BLACK,
        "cyan": curses.COLOR_CYAN,
        "magenta": curses.COLOR_MAGENTA,
        "white": curses.COLOR_WHITE,
        "blue": curses.COLOR_BLUE,
        "green": curses.COLOR_GREEN,
        "red": curses.COLOR_RED,
        "yellow": curses.COLOR_YELLOW
    }

    weights = {
        "alt": curses.A_ALTCHARSET,
        "blink": curses.A_BLINK,
        "bold": curses.A_BOLD,
        "dim": curses.A_DIM,
        "normal": curses.A_NORMAL,
        "reverse": curses.A_REVERSE,
        "standout": curses.A_STANDOUT,
        "underlined": curses.A_UNDERLINE
    }

    def __init__(self, text, fcolor="default", bcolor="default", weight="normal"):
        self.text = unicode_str(text)
        self.fcolor = self.colors.get(fcolor, -1)
        self.bcolor = self.colors.get(bcolor, -1)
        self.weight = self.weights[weight]

class Searcher(object):

    def __init__(self,
            ranker,
            output,
            whitespace_separated_multiquery=False,
            match_on_path_query=False):
        self.ranker = ranker
        self.output = output
        self.whitespace_separated_multiquery = whitespace_separated_multiquery
        self.match_on_path_query = match_on_path_query

    def _getch(self, blocking=True):
        if blocking:
            self.output.window.timeout(-1)
        else:
            self.output.window.timeout(100)
        c = self.output.window.getch()
        if blocking: # restore
            self.output.window.timeout(-1)
        return c

    def _newHeap(self, query, curHeap):
        newHeap = []
        ranker = self.ranker(query=query,
                whitespace_separated_multiquery=self.whitespace_separated_multiquery,
                match_on_path_query=self.match_on_path_query)
        for w, item in curHeap:
            score = ranker.rank(item)
            if score is not None:
                heapq.heappush(newHeap, (score, item))
        return newHeap

    def _topItems(self, heap, N=5):
        h = heap[:]
        items = []
        for _ in range(N):
            if len(h) == 0:
                break
            w, item  = heapq.heappop(h)
            items.append(item)
        return items

    def _loop(self, curHeaps, N):
        heapq.heapify(curHeaps[0])

        cur = ""
        selected = 0
        while True:
            self.output.window.timeout(-1)
            next_char = self._getch(blocking=True)

            # Escape: could be just Escape, could be Ansi escape for
            # arrows
            if next_char == 27:

                # just escape? try non-blocking read to see if
                # any other characters
                next_char = self._getch(blocking=False)
                if next_char == -1:
                    raise KeyboardInterrupt()

                # other characters available
                # assuming arrow-key, we discard
                # the current and read the next
                next_char = self._getch(blocking=True)

                # Up/down
                if next_char == 66:
                    itemsShown = min(N, len(curHeaps[-1])) - 1
                    selected = min(itemsShown, selected + 1)
                elif next_char == 65:
                    selected = max(0, selected - 1)

            else :
                # Selected
                if next_char == 10 or next_char == 13: # enter
                    h = curHeaps[-1]
                    for _ in range(selected):
                        if not h: break
                        heapq.heappop(h)

                    return heapq.heappop(h)[1] if h else None

                selected = 0

                # Escape code
                if next_char in (3, 4, 28, 26):
                    raise KeyboardInterrupt()

                # Delete/backspace
                if next_char in (8, 127):
                    if cur != "":
                        cur = cur[:-1]
                        curHeaps.pop()
                else:
                    cur += chr(next_char)
                    curHeaps.append(self._newHeap(cur, curHeaps[-1]))

            self._echo(cur, curHeaps[-1], selected, N)

    def _echo(self, cur, heap, selected, N):
        self.output.clear()
        self.output.printQuery(cur)

        for i, item in enumerate(self._topItems(heap, N)):
            self.output.printItem(i, item, i==selected, cur)

        self.output.flush()


    def run(self, items, rows):
        self.output.init()
        try:
            heap = [(0, i) for i in items]
            heap.sort()
            self._echo("", heap, 0, N=rows)
            return self._loop([heap], rows)
        finally:
            self.output.cleanup()

##############################################################################
## DirectorySource.py

File = collections.namedtuple("File", "dir,name,sname")
class DirectorySource(object):

    def __init__(self, dir=".", ignore_directories=True, ignore_files=True, git_ignore=True):
        self.ignore_directories = ignore_directories
        self.ignore_files = ignore_files
        self.git_ignore = git_ignore
        self.startDir = dir
        self.filters = []
        if git_ignore:
            self.find_parent_gis()

    def find_parent_gis(self):
        dirs = rec_dir_up(self.startDir)
        next(dirs)
        # dirs.next()
        for dirname in dirs:
            pgi = os.path.join(dirname, '.gitignore')
            if os.path.isfile(pgi):
                self.filters.append(GitIgnoreFilter(dirname, '.gitignore'))
        self.filters.reverse()

    def fetch(self):
        lst = []
        for dirname, dirs, filenames in walk(self.startDir):
            names = []
            if not self.ignore_files:
                names = filenames
            if not self.ignore_directories:
                names.extend(dirs)

            if self.git_ignore and '.gitignore' in filenames:
                gif = GitIgnoreFilter(dirname, '.gitignore')
                self.filters.append((dirname, gif))

            while self.filters:
                path, _ = self.filters[-1]
                if dirname.startswith(path): break
                self.filters.pop()

            fltr = None
            if self.filters:
                fltr = self.filters[-1][1]

            if fltr is None:
                files = (File(dirname, name, name.lower()) for name in names)
            else:
                files = (File(dirname, name, name.lower())
                        for name in names if fltr(name, dirname))
            lst.extend(files)

            # have to delete the names manually
            if fltr is not None:
                for i in range(len(dirs) - 1, -1, -1):
                    if not fltr(dirs[i], dirname):
                        del dirs[i]

        return lst

class GitIgnoreFilter(object):
    # Optimization
    lastdir = None
    last_path_filter = None

    globchars = re.compile('[*\[\]?]')
    def __init__(self, dirname, filename):
        self.dirname = dirname
        self.fn = os.path.join(dirname, filename)
        path_filters = []
        glob_filters = []
        exact_filters = set(['.git'])
        with open(self.fn) as f:
            gc = self.globchars
            for fn in f:
                if fn.startswith('#'):
                    continue

                fn = fn.strip()
                if fn.startswith('/'):
                    path_filters.append(fn)
                elif gc.search(fn) is not None:
                    glob_filters.append(fnmatch.translate(fn.strip()))
                else:
                    exact_filters.add(fn)

        if glob_filters:
            self.glob_filters = [re.compile('|'.join(glob_filters))]
        else:
            self.glob_filters = []

        self.exact_filters = exact_filters
        self.path_filters = self.setup_path_filters(path_filters)

    def setup_path_filters(self, path_filters):
        # We can currently glob on only filename positions
        dirmaps = {}
        for pf in path_filters:
            while pf.endswith('/'):
                pf = pf[:-1]

            dirname, basename = os.path.split(pf)
            dm = os.path.join(self.dirname, dirname.lstrip('/'))
            glob = fnmatch.translate(basename.strip())
            if dm in dirmaps:
                dirmaps[dm].append(glob)
            else:
                dirmaps[dm] = [glob]

        # Build glob maps
        for k in dirmaps.keys():
            vs = dirmaps[k]
            dirmaps[k] = re.compile('|'.join(vs))

        return dirmaps

    def __call__(self, fn, dirname):
        # check exact
        if fn in self.exact_filters:
            return False
        # Check global globs
        for f in self.glob_filters:
            if f.match(fn) is not None:
                return False

        lpf = self.path_filters.get(dirname)

        # check path dependent globs
        if lpf is not None and lpf.match(fn) is not None:
            return False

        return True

class FuzzyRanker(object):

    def __init__(self,
            query,
            whitespace_separated_multiquery=False,
            match_on_path_query=False):
        self.whitespace_separated_multiquery = whitespace_separated_multiquery
        self.match_on_path_query = match_on_path_query
        self.weight_f = lambda f: f.dir.count(os.sep) ** 0.5
        self.qs = query.lower()
        if self.whitespace_separated_multiquery:
            self.qs = self.qs.split()
        else:
            self.qs = [self.qs]

    # def rank_part(self, q, part):
    #     if q not in part:
    #         return None
    #     score = (len(part) - len(q)) ** 0.5
    #     score -= 1.0 if part.startswith(q) else 0.0
    #     score -= 1.0 if part.endswith(q) else 0.0
    #     return score

    def score(self, pattern, s):
        match = re.search(pattern, s)
        if match is None:
            return None
        else:
            # return 100 / ((1+match.start()) * (match.end()-match.start()+1))
            return 1000.0 / ((1 + match.start()) * (match.end() - match.start() + 1))

    def rank(self, item):
        if self.match_on_path_query:
            part = os.path.join(item.dir.lower(), item.sname)
        else:
            part = item.sname
        agg_score = 0.0
        for q in self.qs:
            # score = self.rank_part(q, part)
            pattern = '.*?'.join(map(re.escape, list(q)))
            score = self.score(pattern, part)
            if score is None or score == 0:
                return None
            if score is not None:
                agg_score += score

        return agg_score + self.weight_f(item)

def FilePrinter(f, query, length):
    v = truncate_middle(os.path.join(f.dir, f.name), length)
    return highlight(v, query)


##############################################################################
## Console.py

def getDims():
    env = os.environ
    def ioctl_GWINSZ(fd):
        try:
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
        except:
            return
        return cr

    return ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2) or (25, 80)

##############################################################################
## Main Code

class Runner(object):
    def __init__(self, args):
        self.rows, self.columns = getDims()
        self.args = args
        self.editor_path = os.environ.get("FUZZYSNAKE_EDITOR", os.environ.get("EDITOR", "vi"))

    def find(self):
        raise NotImplementedError()

    def run(self):
        filename = self.find()
        if filename is not None:
            if self.args.save_to_file is not None:
                with open(self.args.save_to_file, 'w') as f:
                     f.write(filename)
            else:
                try:
                    os.execvp(self.editor_path, [self.editor_path, filename])
                except:
                    sys.stderr.write("Failed to execute: os.execvp('{}', ['{}', {}])\n".format(self.editor_path, self.editor_path, filename))
                    exit(1)

class DirRun(Runner):

    def find(self):

        git_ignore = self.args.include_gitignore_files
        if self.args.fileType == 'all':
            ds = DirectorySource(ignore_directories=False,
                    ignore_files=False, git_ignore=git_ignore)
        elif self.args.fileType == 'files':
            ds = DirectorySource(ignore_files=False, git_ignore=git_ignore)
        else:
            ds = DirectorySource(ignore_directories=False, git_ignore=git_ignore)

        items = ds.fetch()

        f = functools.partial(FilePrinter, length=self.columns)
        ranker = FuzzyRanker
        s = Searcher(ranker=ranker,
                output=CursesPrinter(f),
                whitespace_separated_multiquery=self.args.whitespace_separated_multiquery,
                match_on_path_query=self.args.match_path,
                )
        try:
            found = s.run(items, self.rows - 3)
        except KeyboardInterrupt:
            sys.exit(0)

        if found is not None:
            found = os.path.join(found.dir, found.name)
        return found

def build_arg_parser():
    parser = argparse.ArgumentParser(description=__description__)
    parser.add_argument("--version", action="version", version="FuzzySnake " + __version__)
    parser.add_argument('-s', '--save-to-file',
            metavar="FILENAME",
            help='Writes the file to provided file instead of executing it.')
    parser.add_argument('-g', '--include-gitignore-files',
            action="store_false", help='Do not filter out files in .gitignore')
    parser.add_argument('-w', '--whitespace-separated-multiquery',
            action="store_true", help='Whitespace separates multiple queries')
    parser.add_argument('-p', '--match-path',
            action="store_true", help='Match on full directory path as well as basename')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('-d', action="store_const", dest="fileType", const="dirs",
                        help='Directories only.')
    group.add_argument('-a', action="store_const", dest="fileType", const="all",
                        help='Both files and directories.')
    parser.set_defaults(fileType="files")

    return parser.parse_args()

if __name__ == '__main__':
    args = build_arg_parser()
    runner = DirRun(args)
    runner.run()
